<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sender — Server-side send (AES-GCM + RSA) Demo</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; padding: 20px; max-width: 980px; margin: auto; }
    h1 { font-size: 1.4rem; }
    label { display:block; margin-top:12px; }
    textarea { width:100%; height:120px; font-family: monospace; padding:8px; }
    input[type=text] { width: 100%; padding:8px; }
    button { margin-top:12px; padding:10px 14px; border-radius:6px; border: none; background:#0366d6; color:white; cursor:pointer; }
    button:disabled { opacity:0.5; cursor:not-allowed }
    .card { border:1px solid #ddd; padding:12px; border-radius:8px; margin-top:12px; background:#fafafa }
    pre { background:#111; color:#eee; padding:10px; border-radius:6px; overflow:auto }
    .spinner { width:14px; height:14px; border-radius:50%; border:3px solid #ddd; border-top-color:#0366d6; animation: spin 1s linear infinite; display:inline-block; vertical-align:middle; margin-right:8px }
    .hidden { display:none }
    .ok { color:green; font-weight:600 }
    .err { color:crimson; font-weight:600 }
    .field { word-break:break-all; font-family: monospace; font-size:0.9rem; }
    .messages { margin-top:12px; }
    .msg { padding:6px 8px; border-radius:6px; background:#fff; border:1px solid #eee; margin-bottom:8px }
    .msg .small { font-size:0.85rem; color:#555 }
    @keyframes spin { to { transform: rotate(360deg) } }
  </style>
</head>
<body>
  <h1>Sender — Server-side send (AES-GCM + RSA) Demo</h1>

  <div class="card">
    <label>Sender ID: <input id="senderId" type="text" value="alice" /></label>
    <label>Receiver ID: <input id="receiverId" type="text" value="bob" /></label>
    <label>Message to encrypt:</label>
    <textarea id="plaintext">Hello Bob — this message is confidential.</textarea>
    <button id="startBtn">Encrypt (server-side) &amp; Send</button>

    <!-- Messages (log) appear directly under the button -->
    <div id="messages" class="messages"></div>
  </div>

  <div class="card">
    <h3>Results & Outputs (from server)</h3>

    <div>
      <strong>IV (Base64):</strong>
      <div id="iv" class="field">—</div>
    </div>

    <div>
      <strong>Ciphertext (Base64):</strong>
      <pre id="ciphertext">—</pre>
    </div>

    <div>
      <strong>Encrypted (wrapped) AES key with receiver's public key (Base64):</strong>
      <div id="wrappedKey" class="field">—</div>
    </div>

    <div>
      <strong>Signature (Base64):</strong>
      <div id="signature" class="field">—</div>
    </div>

    <div>
      <strong>Server response (full):</strong>
      <pre id="serverResp">—</pre>
    </div>
  </div>

  <script>
    // Helpers
    const textEncoder = new TextEncoder();
    const setField = (id, txt) => document.getElementById(id).textContent = txt;
    const messagesEl = document.getElementById('messages');

    function appendMsgNode(text) {
      const d = document.createElement('div'); d.className = 'msg';
      d.innerHTML = `<span class="small">${text}</span>`;
      messagesEl.appendChild(d);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return d;
    }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function runStep(text, action) {
      const node = appendMsgNode(text);
      const spinner = document.createElement('span'); spinner.className = 'spinner';
      node.prepend(spinner);
      try {
        const result = await action();
        await sleep(1200 + Math.floor(Math.random()*1000)); // keep spinner visible a bit
        spinner.remove();
        const done = document.createElement('span'); done.textContent = ' ✅'; node.appendChild(done);
        return result;
      } catch (e) {
        spinner.remove();
        const err = document.createElement('span'); err.textContent = ' ✖'; err.style.color='crimson'; node.appendChild(err);
        const em = document.createElement('div'); em.className='small'; em.textContent = 'Error: ' + (e && e.message ? e.message : e); node.appendChild(em);
        throw e;
      }
    }

    // ensure server has keypairs for both users
    async function ensureServerKeys(userA, userB) {
      await runStep('Init: creating server-side keypair for ' + userA + '...', async () => {
        const r = await fetch('/api/keys/generate?userId=' + encodeURIComponent(userA), { method: 'POST' });
        if (!r.ok) { const t = await r.text(); throw new Error('Failed to create keypair for ' + userA + ': ' + r.status + ' ' + t); }
        return true;
      });
      await runStep('Init: creating server-side keypair for ' + userB + '...', async () => {
        const r = await fetch('/api/keys/generate?userId=' + encodeURIComponent(userB), { method: 'POST' });
        if (!r.ok) { const t = await r.text(); throw new Error('Failed to create keypair for ' + userB + ': ' + r.status + ' ' + t); }
        return true;
      });
    }

    document.getElementById('startBtn').addEventListener('click', async () => {
      const startBtn = document.getElementById('startBtn');
      startBtn.disabled = true;
      messagesEl.innerHTML = '';
      setField('iv','—'); setField('ciphertext','—'); setField('wrappedKey','—'); setField('signature','—'); setField('serverResp','—');

      try {
        const senderId = (document.getElementById('senderId').value || 'alice').trim();
        const receiverId = (document.getElementById('receiverId').value || 'bob').trim();
        const plaintext = document.getElementById('plaintext').value || '';

        // 0) Ensure server has both keypairs (so send endpoint can sign and wrap)
        await ensureServerKeys(senderId, receiverId);

        // 1) Ask server to perform send (server generates AES key, encrypts, wraps key, signs)
        const respObj = await runStep('1) Requesting server to encrypt, wrap key, and sign (/api/message/send)', async () => {
          const resp = await fetch('/api/message/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ senderId, receiverId, plaintext })
          });
          if (!resp.ok) {
            const txt = await resp.text();
            throw new Error('Server error: ' + resp.status + ' ' + txt);
          }
          return await resp.json();
        });

        // Display server-returned fields
        setField('iv', respObj.iv || '—');
        setField('ciphertext', respObj.ciphertext || '—');
        setField('wrappedKey', respObj.encryptedAesKey || '—');
        setField('signature', respObj.signature || '—');
        setField('serverResp', JSON.stringify(respObj, null, 2));

        appendMsgNode('Package received from server and displayed above.');

        // 2) Optionally: forward this package to receiver endpoint or save locally (not done here)
        appendMsgNode('Send flow complete. If you want the receiver to decrypt, POST the package to /api/message/receive from the receiver side.');

      } catch (err) {
        console.error(err);
        appendMsgNode('Fatal error: ' + (err && err.message ? err.message : err), 'err');
      } finally {
        startBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
